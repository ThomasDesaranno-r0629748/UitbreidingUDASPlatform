<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <link rel="stylesheet" type="text/css" href="Style.css">
    <title>AstMAPPING</title>
</head>

<body>
    <script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="/d3.geo.tile.min.js" charset="utf-8"></script>
    <script src="/hexbin.js" charset="utf-8"></script>
    <script src="/viridis_colors.js" charset="utf-8"></script>
    <!--Script met alle basic functies van de map-->
    <script>
        var width = Math.max(960, window.innerWidth),
            height = Math.max(500, window.innerHeight),
            prefix = prefixMatch(["webkit", "ms", "Moz", "O"]);

        var tile = d3.geo.tile()
            .size([width, height]);

        /*Deze variabele stelt de coordinaten in waarop de map zich centreerd*/
        var leuven = [4.7009300, 50.8795900];

        /*Hier de scale aanpassen van de map*/
        var projection = d3.geo.mercator()
            .scale((1 << 22) / 2 / Math.PI)
            .translate([width / 2, height / 2]);

        var center = projection(leuven);

        var zoom = d3.behavior.zoom()
            .scale(projection.scale() * 2 * Math.PI)
            .scaleExtent([1 << 9, 1 << 23])
            .translate([width - center[0], height - center[1]])
            .on("zoom", zoomed);

        var map = d3.select("body").append("div")
            .attr("class", "map")
            .style("width", width + "px")
            .style("height", height + "px")
            .call(zoom)
            .on("mousemove", mousemoved);

        var layer = map.append("div")
            .attr("class", "layer");

        var info = map.append("div")
            .attr("class", "info");

        zoomed();

        function zoomed() {
            var tiles = tile
                .scale(zoom.scale())
                .translate(zoom.translate())
                ();

            projection
                .scale(zoom.scale() / 2 / Math.PI)
                .translate(zoom.translate());

            var image = layer
                .style(prefix + "transform", matrix3d(tiles.scale, tiles.translate))
                .selectAll(".tile")
                .data(tiles, function (d) {
                    return d;
                });

            image.exit()
                .remove();

            image.enter().append("img")
                .attr("class", "tile")
                .attr("src", function (d) {
                    return "http://" + ["a", "b", "c"][Math.random() * 3 | 0] + ".tile.openstreetmap.org/" + d[2] + "/" + d[0] + "/" + d[1] + ".png";
                })
                .style("left", function (d) {
                    return (d[0] << 8) + "px";
                })
                .style("top", function (d) {
                    return (d[1] << 8) + "px";
                });
        }

        function mousemoved() {
            info.text(formatLocation(projection.invert(d3.mouse(this)), zoom.scale()));
        }

        function matrix3d(scale, translate) {
            var k = scale / 256,
                r = scale % 1 ? Number : Math.round;
            return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1] + ")";
        }

        function prefixMatch(p) {
            var i = -1,
                n = p.length,
                s = document.body.style;
            while (++i < n)
                if (p[i] + "Transform" in s) return "-" + p[i].toLowerCase() + "-";
            return "";
        }

        function formatLocation(p, k) {
            var format = d3.format("." + Math.floor(Math.log(k) / 2 - 2) + "f");
            return (p[1] < 0 ? format(-p[1]) + "째S" : format(p[1]) + "째N") + " " + (p[0] < 0 ? format(-p[0]) + "째W" : format(p[0]) + "째E");
        }

        
        
        // define hexbins
        var hexbin = d3.hexbin()
            .size([width, height])
            .radius(4);

        var hex = map.append("g")
            .attr("id", "hexbins");

        // first of two scales for linear hexagon fill - ref[1]
        var fill_scale1 = d3.scale.linear()
            .domain(d3.range(0, 1, 1 / (viridis_colors.length - 1)))
            .range(viridis_colors);

        // crash data
        d3.json("all.json", function (data) {
            console.log(data);
            // convert lat/lng to numeric
            data.forEach(function (d) {
                
                d.lat = +d.lat;
                d.lon = +d.lon;
            });

            points = [];

            // x,y maps to lng,lat - ref[2]
            data.forEach(function (d) {
                d.lat = 50.883333;
                d.lon = 4.700000;
                var x = projection([d.lon, d.lat])[0];
                var y = projection([d.lon, d.lat])[1];
                console.log(x+"test");
                points.push([x, y]);
            });

            // bin coords
            var bins = hexbin(points);
            var bins_n = []; // points per hexbin
            bins.forEach(function (d) {
                bins_n.push(d.length);
            });

            // second of two scales for linear hexagon fill - ref[1]
            var extent = d3.extent(bins_n);
            var fill_scale2 = d3.scale.linear()
                .domain([extent[0], extent[1]])
                .range([0, 1]);

            hex.selectAll(".hexagon")
                .data(hexbin(points))
                .enter()
                .append("path")
                .attr("class", function (d) {
                    return "hexagon bin_" + d.length;
                })
                .attr("d", hexbin.hexagon())
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                })
                .style("fill", function (d) {
                    return fill_scale1(fill_scale2(d.length));
                });
        })
    </script>
</body>